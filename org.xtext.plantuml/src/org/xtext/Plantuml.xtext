// Class for generating the grammar for the PlantUML language.
grammar org.xtext.Plantuml 
	//with org.eclipse.xtext.common.Terminals
	hidden (WS, SL_COMMENT, ML_COMMENT)
generate plantuml "http://www.xtext.org/Plantuml"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore


// Model is a number of @startuml's and @enduml's
Plantuml:
	NEWLINE* (diagrams+=Diagram)*;
	
// A diagram starts with @Startuml and ends with @enduml, with some number of instructions in between
Diagram:
	START NEWLINE (instructions+=Instruction)+ END NEWLINE*
;

// An instruction can be any of the rules for single- and multiline commands.
Instruction: 
	{Instruction}(instr=Sequence
	|instr=Definition
	|instr=AutoNumber
	|instr=Title
	|instr=Legend
	|instr=Newpage
	|instr=GroupingMessages
	|instr= Note
	|instr= Divider
	|instr= Reference 
	|instr= Delay
	|instr= Space
	|Hidefootbox
	|instr=Activate
	|instr=Deactivate
	|instr= ParticipantCreation
	|instr=Box
	|instr=IncOut
	|instr= Skinparam
	|instr= UC_direction)? NEWLINE
;


// Rules for handling ID's, Strings, and their respective variations
// ------------------------------------------------------------------
// ------------------------------------------------------------------
Keywords:
	'create'|'autonumber'|'title'|'legend'|'right'|'left'|'center'
	   |'alt'|'else'|'newpage'|'opt'|'loop'|'par'|'break'|'as'
	   |'critical'|'group'|'note'|'over'|'of'|'hide'|'footbox'|'activate'
	   |'actor'|'boundary'|'control'|'entity'|'database'|'participant'
	   |'deactivate'|'destroy'|'box'|'in'|'skinparam'|'sequence'|'hidefootbox'|'ref'
;


SpecialChars:
	'|'|'||'|'#'|ARROWBODY|':'|RIGHTARROWHEAD|LEFTARROWHEAD|'!'|')'|'('|','|'='|'>>'|'<<'
;

ID: BASIC_ID|Keywords|'end'|'endlegend'|CHAR;


Special_String:
	(BASIC_ID|Keywords|SpecialChars|ANY_OTHER|INT|CHAR)*
;


Basic_String:
	(BASIC_ID|Keywords|INT|CHAR)*
;

Full_String:
	Basic_String | Quotes_String |'end' 'legend'?
;

Woend_String:
	Basic_String | Quotes_String |'endlegend'
;

Woendlegend_String:
	Special_String | Quotes_String |'end'
;

Quotes_String:
	'"' Special_String '"'
;


// Rules for declarations of actors
// ------------------------------------------------------------------
// ------------------------------------------------------------------
Declaration: dec=(Definition|Sequence);

// Rule for creating sequences between actors (Not necessarily previously defined)
Sequence:
	arrowIDs+=ArrowID arrow=Arrow arrowIDs+=ArrowID ('!')? (':' Full_String)?
;

ArrowID:
	name=ID | "(" name = ID ")" | ":" name = ID ":"
;


Arrow:
	{Arrow} left=(LEFTARROWHEAD | LEFTARROWHEADEXTENSION)? ('[' '#' Color = Color ']')? 
	leftmid+=ARROWBODY+ ('[' '#'  Color = Color ']' rightmid+=ARROWBODY+)?
	 ('[' '#' Color = Color ']')? right=(RIGHTARROWHEAD | RIGHTARROWHEADEXTENSION)?
;

// Rule for defining objects in PlantUML, such as
// actors, boundaries, controls, entities and databases
Definition:
	Definition_Type (Stereotype = Stereotype)? ('#' Color = Color)?
;


Definition_Type:
	('actor' 
	| 'boundary'
	| 'control'
	| 'entity'
	| 'database'
	| 'participant'
	| 'usecase') name=ID 
	| "(" name=ID ")"
	| ":" name=ID ":"
;


// 1.24 Stereotype, used in Participant_Declaration
Stereotype:
	{Stereotype}'<<' ('(' CHAR ',' '#' Color = Color ')')? Full_String '>>'
;

// ------------------------------------------------------------------
// ------------------------------------------------------------------



// Rule for the autonumbering function. Can be followed by one or two numbers, separated by spaces
AutoNumber:
	{AutoNumber}'autonumber' (numbers+=INT (numbers+=INT)?)? Quotes_String?
;

// Rule for the title of the diagram
Title:
	'title' title=Full_String
;

// Rule for legends.
Legend:
	{Legend} 'legend' (pos=('right' | 'left' | 'center'))? 
	(NEWLINE Woendlegend_String)* NEWLINE ('endlegend'|'end legend')
;

// Rule for newpages
Newpage:
	'newpage' text=Full_String
;

Else:
	{Else}'else' Full_String NEWLINE (instructions+=Instruction)*
;

// Rule for "grouping-messages"
GroupingMessages:
	 {GroupingMessages}('opt'|'loop'|'par'|'break'|'critical'|'group'|'alt') Full_String NEWLINE 
	(instructions+=Instruction)* (elses+=Else)* 'end'
;

// Rule for notes
Note:
	{Note}'note' (('right' ('of' rid=[Declaration|ID] (',' rids+=[Declaration|ID])*)?)
		   		 |('left' ('of' lid=[Declaration|ID] (',' lids+=[Declaration|ID])*)?)
		  		 |('over' oid=[Declaration|ID](',' oids+=[Declaration|ID])*))
		 		  ('#' Color = Color)? ((':' Full_String)| ((NEWLINE Woend_String)* NEWLINE 'end''note'|'endnote'))
;

// Rule for Dividers.
Divider:
	'==' text=Full_String '=='
;

// Rule for References
Reference:
	'ref over' (ids+=[Declaration|ID]) (',' ids+=[Declaration|ID])* 
	(( ':' Full_String)|((NEWLINE Full_String)* NEWLINE ('endref'|('end ref'))))
;

// Rule for delays
// TODO: Read full strings even when containing dots (....).
Delay:
	{Delay}'...' (text=Full_String '...')?
;

// Rule for Spaces
Space:
	{Space}('|||'|('||' number=INT '||'))
;

// Rule for hiding the footbox
Hidefootbox:
	'hide footbox'|'hide''footbox'|'hidefootbox'
;

// Rules for activation, deactivation and destruction of lifelines
Activate:
	'activate' name=ID  ('#'(Color = Color))?
;

Deactivate:
	('deactivate'|'destroy') id=[Activate|ID]
;

// Rule for Participant Creation
ParticipantCreation:
	'create' (name=ID|Definition)
;

// Rule for box/end box
Box:
	{Box}'box' Quotes_String ('#' Color = Color)? NEWLINE
	(boxinstructions+=Instruction)+
	'end box'
;

IncArrow:
	('[' ARROWBODY+ RIGHTARROWHEAD)|('[' LEFTARROWHEAD ARROWBODY+)
;
OutArrow:
	(LEFTARROWHEAD ARROWBODY+ ']')|(ARROWBODY+ RIGHTARROWHEAD ']')
;

// Rule for incoming and outgoing messages
IncOut:
	((IncArrow name = ID)|(name = ID OutArrow)) (':' Full_String)?
;

Skinparam:
	{Skinparam}'skinparam' cmd+=SkinparamCommand
	| {Skinparam}'skinparam' id=ID '{' NEWLINE (cmd+=SkinparamCommand? NEWLINE)* '}'
;
SkinparamCommand:
	{SkinparamCommand} key=ID '#'? (val=INT|BASIC_ID)
;
/*SkinparamCommand:
	{SkinparamCommand} ('ArrowColor' '#' Color=Color
	|'ActorBorderColor' '#'Color=Color
	|'LifeLineBorderColor' '#' Color=Color
	|'LifeLineBackgroundColor' '#' Color=Color
	|'ParticipantBorderColor' '#' Color=Color
	|'ParticipantBackgroundColor' '#' Color=Color
	|'ParticipantFontName' ID
	|'ParticipantFontColor' '#' Color=Color
	|'ParticipantFontSize' INT
	|'ActorBackgroundColor' '#' Color=Color
	|'ActorFontColor' '#' Color=Color
	|'Actorfontsize' INT
	|'ActorFontName' ID)
;*/

// 2.11 direction usecase diagram is painted in (vertical or horizontal)
UC_direction:
	direction=("top to bottom direction"
	| "left to right direction")	
;


// ValueConverter checks if the Color is a proper color or a hexcode
Color: ID|INT;

// Terminals
// ------------------------------------------------------------------
// ------------------------------------------------------------------

terminal NEWLINE 	: ('\r'? '\n');

terminal START		: '\u0040' 'startuml';

terminal END		: '\u0040' 'enduml';

// Multiline comment begins with /', and ends with '/
terminal ML_COMMENT : '/\'' -> '\'/'; 

// Singleline comment begins with ', and continues until end of line.
terminal SL_COMMENT : '\'' !('\n'|'\r')*;

terminal ARROWBODY:
	'.' | '=' | '-'
;

terminal RIGHTARROWHEAD:
	'>'
;

terminal LEFTARROWHEAD:
	'<'
;

terminal RIGHTARROWHEADEXTENSION:
	'x' | '>o' | '>x'
;

terminal LEFTARROWHEADEXTENSION:
	'x' | 'o<' | 'x<'
;

// INT is a sequence of numbers 0-9.
terminal INT returns ecore::EInt: ('0'..'9')+;

terminal CHAR: ('a'..'z'|'A'..'Z'|'0'..'9' | 'å' | 'ä' | 'ö');

terminal BASIC_ID: ('a'..'z'|'A'..'Z'|'0'..'9' | 'å' | 'ä' | 'ö')*;

terminal WS: (' '|'\t')+;

terminal ANY_OTHER: .;


