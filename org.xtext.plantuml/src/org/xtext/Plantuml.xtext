// Class for generating the grammar for the PlantUML language.


grammar org.xtext.Plantuml 
	//with org.eclipse.xtext.common.Terminals
	hidden (WS, SL_COMMENT, ML_COMMENT)

generate plantuml "http://www.xtext.org/Plantuml"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// Model is a number of @startuml's and @enduml's
Model:
	(diagrams+=Diagram)*;
	
// A diagram starts with @Startuml and ends with @enduml, 
// with some number of instructions in between
Diagram:
	START NEWLINE (instructions+=(Instruction))* END NEWLINE*
;

// An instruction can be any of the rules for single- and multiline commands.
Instruction: 
	((name1=ID SEQUENCE name2=ID (':' ID)?) 
	| Definition (Color)?
	| AutoNumber
	| Title
	| Legend
	| Newpage
	| AltElse
	| GroupingMessages
	| Note
	| Divider
	| Reference
	| Delay
	| Space
	| Hidefootbox
	| Lifeline
	| ParticipantCreation
	| Box)? NEWLINE
;

// Rule for sequences.
// A sequence is any of the following arrows:

	
// Rule for defining objects in PlantUML, such as
// actors, boundaries, controls, entities and databases
Definition:
	'actor' name=ID 
	| 'boundary' name=ID
	| 'control' name=ID
	| 'entity' name=ID
	| 'database' name=ID
	// Change second ID in participant to Single-Line String.
	| 'participant' name=ID ('<<' (('(' ID ',' Color ')')|('(' ID ',' Color ')' ID)| ID) '>>')?

;

// Rule for the autonumbering function. Can be followed by one or two numbers, separated by spaces
AutoNumber:
	'autonumber' (INT (INT)?)?
;

// Rule for all the color. Color begins with # followed by the name of the color.
// TODO: Fix to ignore lower/uppercase.
Color:
	'#'+('AliceBlue'|'AntiqueWhite'|'Aqua'|'Aquamarine'|'Azure'|'Beige'|'Bisque'|'Black'|'BlanchedAlmond'
	|'Blue'|'BlueViolet'|'Brown'|'BurlyWood'|'CadetBlue'|'Chartreuse'|'Chocolate'|'Coral'
	|'CornflowerBlue'|'Cornsilk'|'Crimson'|'Cyan'|'DarkBlue'|'DarkCyan'|'DarkGoldenRod'|'DarkGray'
	|'DarkGreen'|'DarkGrey'|'DarkKhaki'|'DarkMagenta'|'DarkOliveGreen'|'DarkOrchid'|'DarkRed'
	|'DarkSalmo'|'DarkSeaGreen'|'DarkSlateBlue'|'DarkSlateGray'|'DarkSlateGrey'|'DarkTurquoise'
	|'DarkViolet'|'Darkorange'|'DeepPink'|'DeepSkyBlue'|'DimGray'|'DimGrey'|'DodgerBlue'
	|'FireBrick'|'FloralWhite'|'ForestGreen'|'Fuchsia'|'Gainsboro'|'GhostWhite'|'Gold'
	|'GoldenRod'|'Gray'|'Green'|'GreenYellow'|'Grey'|'HoneyDew'|'HotPink'|'IndianRed'
	|'Indigo'|'Ivory'|'Khaki'|'Lavender'|'LavenderBlush'|'LawnGreen'|'LemonChiffon'
	|'LightBlue'|'LightCoral'|'LightCyan'|'LightGoldenRodYellow'|'LightGray'|'LightGreen'
	|'LightGrey'|'LightPink'|'LightSalmon'|'LightSeaGreen'|'LightSkyBlue'|'LightSlateGray'
	|'LightSlateGrey'|'LightSteelBlue'|'LightYellow'|'Lime'|'LimeGreen'|'Linen'|'Magenta'
	|'Maroon'|'MediumAquaMarine'|'MediumBlue'|'MediumOrchid'|'MediumPurple'|'MediumSeaGreen'
	|'MediumSlateBlue'|'MediumSpringGreen'|'MediumTurquoise'|'MediumVioletRed'
	|'MidnightBlue'|'MintCream'|'MistyRose'|'Moccasin'|'NavajoWhite'|'Navy'|'OldLace'
	|'Olive'|'OliveDrab'|'OrangeRed'|'Orchid'|'PaleGoldenRod'|'PaleGreen'
	|'PaleTurquoise'|'PaleVioletRed'|'PapayaWhip'|'PeachPuff'|'Peru'|'Pink'|'Plum'
	|'PowderBlue'|'Purple'|'Red'|'RosyBrown'|'RoyalBlue'|'SaddleBrown'
	|'Salmon'|'SandyBrown'|'SeaGreen'|'Sienna'|'Silver'|'SkyBlue'|'SlateBlue'
	|'SlateGray'|'SlateGrey'|'Snow'|'SpringGreen'|'SteelBlue'|'Tan'|'Teal'|'Thistle'
	|'Tomato'|'Turquoise'|'Violet'|'Wheat'|'White'|'WhiteSmoke'|'Yellow'|'YellowGreen')
;

// Rule for the title of the diagram
// TODO: Fix ID -> STRING. Title can only be one word atm.
Title:
	'title' ID
;

// Rule for legends.
// TODO: Fix ID -> STRING
Legend:
	'legend' ('right' | 'left' | 'center')?  ((NEWLINE ID|NEWLINE)?)* NEWLINE 'endlegend'
;

// Rule for newpages
// TODO: Fix ID -> STRING
Newpage:
	'newpage' (ID)?
;

// Rules for Alt-Else clauses.
AltElse:
	'alt' ID NEWLINE (instructions+=Instruction)* (elses+=Else)* 'end'
;

Else:
	'else' ID NEWLINE (instructions+=Instruction)*
;

// Rule for "grouping-messages"
GroupingMessages:
	('opt'|'loop'|'par'|'break'|'critical') ID NEWLINE (instructions+=Instruction)* 'end'
;
// Rule for groups.
// TODO: Change from ID to String when done
Group:
	'group' ID
;

// Rule for notes
// TODO: Change :ID and NEWLINE ID to STRING
// TODO: Add reference to created defined entity instead of ID
Note:
	'note' (('right' ('of' ID (',' ID)*)?)|('left' ('of' ID(',' ID)*)?)|('over' ID(',' ID)*)) (Color)* (':' ID| (NEWLINE ID)* NEWLINE 'end note')
;

// Rule for Dividers.
// TODO: Change ID -> STRING when done
Divider:
	'==' ID '=='
;

// Rule for References
// TODO: Link to created participant
// TODO: Change : ID -> : STRING when done
Reference:
	'ref over' ID (',' ID)* ((':' ID)|((NEWLINE ID)*) NEWLINE 'end ref') 
;

// Rule for delays
// TODO: Change ID -> STRING when done, maybe should be 1 line only.
Delay:
	'...' ID* '...'
;

// Rule for Spaces
// TODO: Make it possible to "see" the hidden whitespaces.
Space:
	('|||'|('||' INT '||'))
;

// Rule for hiding the footbox
Hidefootbox:
	'hide footbox'
;

// Rule for activation, deactivation and destruction of lifelines
// TODO: to activate, deactivate and destroy, reference should be added to previously created participants
Lifeline:
	('activate' Color?|'deactivate'|'destroy') ID
;

// Rule for Participant Creation
// TODO: Make sure the ID hasn't been created in beforehand.
ParticipantCreation:
	'create' ID
;

// Rule for box/end box
Box:
	'box' '\"' ID '\"' Color? NEWLINE
	(definitions+=Definition NEWLINE)*
	'end box'
;



// Terminals
//--------------------------------------------------
terminal NEWLINE 	: ('\r'? '\n');

terminal START		: '\u0040' 'startuml';

terminal END		: '\u0040' 'enduml';

// ID can be any following sequence of letters and numbers, without spaces between them.
// TODO: Separate between ID's and sequences of words. Not currently possible to have spaces in ID's.
terminal ID  		: '^'?('a'..'z'|'A'..'Z'|'_' | 'å' | 'ä' | 'ö') ('a'..'z'|'A'..'Z'|'_'|'0'..'9' | 'å' | 'ä' | 'ö')*;

// Multiline comment begins with /', and ends with '/
terminal ML_COMMENT : '/\'' -> '\'/';

// Singleline comment begins with ', and continues until end of line.
terminal SL_COMMENT : '\'' !('\n'|'\r')* ('\r'? '\n')?;

// INT is a sequence of numbers 0-9.
terminal INT returns ecore::EInt: ('0'..'9')+;

// Words can be any characters, and can also be divided by newlines.
//terminal WORDS	: 
//			('a'..'z'|'A'..'Z'|'_'|'0'..'9' | 'å' | 'ä' | 'ö' | '\n' | ' ')*;


// Sequences are arrows connecting two actors. Has to be defined in unicode.
terminal SEQUENCE:
	('\u002D')* '\u002D' '\u003E'							// - = u002D  | > = u003E
	| '\u003C' '\u002D' ('\u002D')* 						// < = u003C  | - = u002D
	| '\u002D' '\u003E' 'x'									// - = u002D  | > = u003E
	| 'x' '\u003C' '\u002D' 								// < = u003C | - = u002D
	| ('\u002D')* '\u002D' '\u003E' '\u003E'				// - = u002D | > = u003E
	| '\u003C' '\u003C' '\u002D' ('\u002D')*				// < = u003C | - = u002D
	| ('\u002D')* '\u002D' '\u005C' '\u005C'				// - = u002D
	| '\u002F' '\u002D' ('\u002D')*							// / = u002F | - = u002D
	| '\u002F' '\u002F' '\u002D' ('\u002D')*				// / = u002F | - = u002D
	| ('\u002D')* '\u002D' '\u003E' 'o'						// - = u002D | > = u003E
	| 'o' '\u003C' '\u002D' ('\u002D')*						// < = u003C | - = u002D
	| ('\u002D')* '\u002D' '\u002D' '\u002F' '\u002F' 'o'	// - = u002D | / = u002F
	| 'o' '\\\\' '\u002D' '\u002D' ('\u002D')* 				// - = u002D
	| '\u003C' '\u002D' '\u003E' 							// < = u003C | - = u002D | > = u003E
	| '\u003C' '\u002D' '\u003E' 'o' 						// < = u003C | - = u002D | > = u003E
	| 'o' '\u003C' '\u002D' '\u003E' 						// < = u003C | - = u002D | > = u003E
	| '\u003C' '\u007C' '\u002D' '\u002D' 					// < = u003C | | = u007C | - = u002D
	| '\u002D' '\u002D' '\u007C' '\u003E' 					// - = u002D | | = u007C | > = u003E
	| '\u002E' '\u002E' 									// . = u002E
	| '\u002E'												// . = u002E	
;

terminal WS			: (' '|'\t')+; // Removed \n & \r from this terminal as it was in conflict with terminal 'NEWLINE'  original: (' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER: .;


